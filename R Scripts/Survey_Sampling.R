# The R script aligns with work for SHAPE: Spatial Health and Population Estimator 
# Code generated by: Emma Von Hoene
# Affiliation: George Mason University, Fairfax, VA, USA
# Contact: evonhoen@gmu.edu
# Description: The script written sample surveys in various methods. 
# Larger surveys like BRFSS need to be sampled before being input into SHAPE to reduce computational cost.



## --- Sampling Surveys Script --- ##

# Read in required libraries
# These libraries will need to be installed for first-time users
library(readxl)
library(dplyr)
library(writexl)
library(purrr)
library(tidyr)

############################################
#### SAMPLING DATA WITH X (5000) RECORDS ####
############################################
# Step 1: Load your data
data <- read_excel("Insert file name here!.xlsx")

# Step 2: Select only the relevant columns needed for stratifying (adjust names if needed)
strat_vars <- c("male", "female", "race1", "race2", "race3", "race4",
                "age1", "age2", "age3", "age4", 
                "bach", "n_bach", 
                "income1", "income2", "income3","income4", 
                "urban", "n_urban", "insured", "n_insured")

# Step 3: Create stratum ID
data$stratum <- apply(select(data, all_of(strat_vars)), 1, paste, collapse = "_")

# Step 4: Calculate how many to sample from each stratum
set.seed(123)  # for reproducibility

sample_size <- 10000

stratum_counts <- data %>%
  count(stratum, name = "n_total") %>%
  mutate(n_sample = round(n_total / sum(n_total) * sample_size))

# Step 5: Join counts back to data
data_joined <- data %>%
  left_join(stratum_counts, by = "stratum")

# Step 6: Sample within each stratum
sampled_data <- data_joined %>%
  group_split(stratum) %>%
  map_dfr(~ {
    n_samp <- unique(.x$n_sample)
    slice_sample(.x, n = min(nrow(.x), n_samp))
  })

# Step 7: Save the sample
write.csv(as.data.frame(sampled_data),
           "Insert file name here!.csv")


################################################################
#### SAMPLING DATA BY STATE, or GEOGRAPHIC UNIT FROM SURVEY ####
################################################################
# Step 1: Load your data
data <- read_excel("Insert file name here!.xlsx")

# Step 2: Filter by state, or other column
sampled_data <- data %>%
  filter(`_STATE` == 36)

# Step 3: Save the sample
write_xlsx(as.data.frame(sampled_data),
           "Insert file name here!.xlsx")

#####################################################
#### STRATIFY SAMPLING DATA WITH MINIMUM RECORDS ####
#####################################################
# Step 1: Load your data
data <- read_excel("Insert file name here!.xlsx")

# Step 2: Select only the relevant columns needed for stratification (adjust names if needed)
strat_vars <- c("male", "female", "race1", "race2", "race3", "race4",
                "age1", "age2", "age3", "age4", 
                "bach", "n_bach", 
                "income1", "income2", "income3","income4", 
                "urban", "n_urban", "insured", "n_insured")

data_strata <- data %>%
  select(all_of(strat_vars))

# Step 3: Create a stratum identifier (a group for each unique combination of strata)
data_strata$stratum <- apply(data_strata, 1, paste, collapse = "_")

# Step 4: Sample the **minimum number**, i.e., 1 from each stratum
# Note: Some strata may appear only once â€” you'll keep all those
min_sample <- data_strata %>%
  group_by(stratum) %>%
  slice_sample(n = 1) %>%  # sample 1 from each unique stratum
  ungroup()

# Step 5: Join back to full dataset (to get all original variables)
sampled_data <- data %>% 
  filter(row_number() %in% rownames(min_sample))

# Save the sampled data to an Excel file
df <- as.data.frame(sampled_data)
write_xlsx(df, "Insert file name here!.xlsx")

#####################################################################
#### CALCULATING DISTRIBUTION BETWEEN SAMPLE AND ORIGINAL SURVEY ####
#####################################################################
# 1. List of binary variables to calculate percentages for
binary_vars <- c("male", "female", "race1", "race2", "race3", "race4",
                 "age1", "age2", "age3", "age4", 
                 "bach", "n_bach", 
                 "income1", "income2", "income3","income4", 
                 "urban", "n_urban", "insured", "n_insured", 
                 "leisure_time", "arthritis", "asthma", "cancer",
                  "kidney_disease", "copd", 
                 "heart_disease", "depression", "diabetes", "obesity", "stroke", "binge_drinking", "smoker")

# 2. Function to calculate percentages
calc_percentages <- function(df, vars) {
  df %>%
    summarise(across(all_of(vars), ~ mean(.x) * 100)) %>%
    pivot_longer(everything(), names_to = "Variable", values_to = "Percentage")
}

# 3. Calculate for original and sampled data
original_percentages <- calc_percentages(data, binary_vars) %>%
  mutate(Source = "Original")

sampled_percentages <- calc_percentages(sampled_data, binary_vars) %>%
  mutate(Source = "Sampled")

# 4. Combine both for comparison
comparison_table <- bind_rows(original_percentages, sampled_percentages) %>%
  pivot_wider(names_from = Source, values_from = Percentage)

# 5. View results
print(comparison_table)

# 6: Save the sampled / true percentages
write_xlsx(as.data.frame(comparison_table),
           "Insert file name here!.xlsx")
